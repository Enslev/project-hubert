$option "vcd"
dp PC(
	in jumpto : ns(10);
	in select : ns(2);
	out cout  : ns(32)
	){
	reg c : ns(10);
	$trace(c, "pc.txt");
	always{

		c = (select == 1) ? c + 1: 
				(select == 2) ? jumpto: c;

		cout = c;

	}
}

dp add(
	in x, y : tc(32);
	out o : tc(32)
	) { 
	always {
		o = x + y;
	}
}

dp sub(
	in x, y : tc(32);
	out o : tc(32)
	) { 
	always {
		o = x - y;
	}
}

dp div(
	in A, B : tc(32);
	in start : ns(1);
	out C : tc(32);
	out done : ns(1)
	) { 
	reg Q, R, D : tc(32);
	always {
		$display($dec, "R= ", R);
		// A must be >= B for this to work
		D = (done == 1) ? 0 : (start == 1) ? B : D;
		R = (done == 1) ? 0 : (start == 1) ? A : 
				(R-D < D) ? R : R-D;
		Q = (done == 1) ? 0 : (R-D < D) ? Q : Q+1;
		done = (R-D < D) ? 1 : 0;
		C = Q;

	}
}

dp alu(
	in A, B : tc(32);
	in S : ns(2);
	in start_alu : ns(1);
	out R : tc(32);
	out Z : ns(1);
	out N : ns(1);
	out done_alu : ns(1)
) {
	sig Radd, Rsub, Rdiv : tc(32);
	sig done : ns(1);

	use add(A, B, Radd);
	use sub(A, B, Rsub);
	use div(A, B, start_alu, Rdiv, done);
	

	always {
		R = (S == 0) ? Radd : 
			(S == 1) ? Rsub : Rdiv;

		N = (R < 0) ? 1 : 0;
		Z = (R == 0) ? 1 : 0;
		
		done_alu =  (S == 0) ? 1 :
					(S == 1) ? 1 : done;

	}

}

dp muxalu(
	in S : ns(1);
	in A, B : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A : B;
	}
}

dp muxreg(
	in S : ns(2);
	in A, B, C : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A :
				(S == 1) ? B : C ;
	}
}

dp register(
	in asel, bsel : ns(3);
	in storeenable : ns(1);
	in storesel : ns(3);
	in storedata : tc(32);
	out a, b: tc(32)
) {
	reg r0, r1, r2, r3, r4, r5, r6, r7 : tc(32);
	always {
		r1 = (storeenable == 1 & storesel == 1) ? storedata : r1;
		r2 = (storeenable == 1 & storesel == 2) ? storedata : r2;
		r3 = (storeenable == 1 & storesel == 3) ? storedata : r3;
		r4 = (storeenable == 1 & storesel == 4) ? storedata : r4;
		r5 = (storeenable == 1 & storesel == 5) ? storedata : r5;
		r6 = (storeenable == 1 & storesel == 6) ? storedata : r6;
		r7 = (storeenable == 1 & storesel == 7) ? storedata : r7; 

		a = (asel == 0) ? r0:
			(asel == 1) ? r1:
			(asel == 2) ? r2:
			(asel == 3) ? r3:
			(asel == 4) ? r4:
			(asel == 5) ? r5:
			(asel == 6) ? r6: r7;

		b = (bsel == 0) ? r0:
			(bsel == 1) ? r1:
			(bsel == 2) ? r2:
			(bsel == 3) ? r3:
			(bsel == 4) ? r4:
			(bsel == 5) ? r5:
			(bsel == 6) ? r6: r7;
	}
}

dp testReg(
	in a, b : tc(32);
	in pc : ns(32);
	in zero, neg : ns(1);
	in done_alu : ns(1);

	out asel, bsel : ns(5);
	out storeenable : ns(1);
	out storesel : ns(3);
	out storedata : tc(32);
	out muxregsel : ns(2);
	out pcjump : ns(32);
	out pcselect : ns(2);
	out operand : tc(32);
	out alusel : ns(2);
	out muxalusel : ns(1);
	out start_alu : ns(1)
 ) {
 	reg regzero, regneg, done : ns(1);
 	
 	
	always{
		$display($dec, "Cycle:", $cycle, ", PC=", pc, ", Aout=", a, ", Bout=", b, ", asel=", asel, ", bsel=", bsel);
		$display($dec, "storeenable=", storeenable, ", storesel=", storesel, ", storedata=", storedata);


		$display($dec, "");
		regzero = zero;
		regneg = neg;
	}

	
	sfg init 			{ 	asel=1; bsel=0; storeenable=0; storesel=0; storedata=0; 
							muxregsel = 0; pcjump = 0; pcselect = 0; 
							operand = 3; alusel = 2; muxalusel = 0; start_alu = 1;}
	
	sfg compute 		{ 	asel=1; bsel=0; storeenable=0; storesel=0; storedata=0; 
							muxregsel = 0; pcjump = 0; pcselect = 0; 
							operand = 3; alusel = 2; muxalusel = 0; start_alu = 1;}
	
	sfg checkAluDone 	{ 	asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; 
							muxregsel = 0; pcjump = 0; pcselect = 0; operand = 0; 
							alusel = 0; muxalusel = 0; start_alu = 0;
							
							done = (alusel == 2) ? done_alu : 1 ;
						}
	
	sfg incpc 			{ 	asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; 
							muxregsel = 0; pcjump = 0; pcselect = 0; operand = 0; 
							alusel = 0; muxalusel = 0; start_alu = 0;}

	/*
	sfg test_0 { asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; muxregsel = 0; pcjump = 0; pcselect = 0; operand = 0; alusel = 0; muxalusel = 0; start_alu = 0;}
	sfg test_1 { asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; muxregsel = 0; pcjump = 17; pcselect = regzero*2; operand = 0; alusel = 0; muxalusel = 0; start_alu = 0;}
	sfg test_2 { asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; muxregsel = 0; pcjump = 0; pcselect = 0; operand = 0; alusel = 0; muxalusel = 0; start_alu = 0;}
	sfg test_3 { asel=0; bsel=0; storeenable=0; storesel=0; storedata=0; muxregsel = 0; pcjump = 0; pcselect = 0; operand = 0; alusel = 0; muxalusel = 0; start_alu = 0;}
	*/


}


fsm f_testbench(testReg) {
	initial s0;
	state s1, s2;

	@s0 (init) -> s1;
	@s1 (compute) -> s2;
	@s2 if (done) then (incpc) -> s1;
		else (checkAluDone) -> s2;
}

dp disp(
	in a : tc(32)
) {
	always {
		$display($dec, "DISP ", a);
	}
}

system myFirstSystem {
	
	register(asel, bsel, storeenable, storesel, muxregout, a, b);
	muxreg(muxregsel, storedata, a, aluout, muxregout);
	muxalu(muxalusel, operand, b, muxaluout);
	alu(a, muxaluout, alusel, start_alu, aluout, zero, neg, done_alu);
	testReg(a, b, pc, zero, neg, done_alu, asel, bsel, storeenable, storesel, storedata, muxregsel, pcjump, pcselect, operand, alusel, muxalusel, start_alu);
	PC(pcjump, pcselect, pc);
	//disp(muxregout);

}