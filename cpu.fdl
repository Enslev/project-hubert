$option "vcd"
dp PC(
	in jumpTo : ns(10);
	in select : ns(1);
	out cout  : ns(32)
	){
	reg c : ns(10);
	
	always{

		c = (select == 1) ? jumpTo: c + 1;
		cout = c;

	}
}

ipblock instmem(
	in address	: ns(5);
	in wr,rd 	: ns(1);
	in idata 	: ns(32);
	out odata 	: ns(32)
) {
	iptype "ram";
	ipparm "size=251";
	ipparm "wl=32";
	ipparm "file=instructions.txt";
}

dp add(
	in x, y : tc(32);
	out o : tc(32)
	) { 
	always {
		o = x + y;
	}
}

dp sub(
	in x, y : tc(32);
	out o : tc(32)
	) { 
	always {
		o = x - y;
	}
}

dp alu(
	in S : ns(1);
	in A, B : tc(32);
	out R : tc(32);
	out Z : ns(1);
	out N : ns(1)
) {
	sig Radd, Rsub : tc(32);

	use add(A, B, Radd);
	use sub(A, B, Rsub);

	always {
		R = (S == 0) ? Radd : Rsub;

		N = (R < 0) ? 1 : 0;
		Z = (R == 0) ? 1 : 0;
	}

}

dp muxalu(
	in S : ns(1);
	in A, B : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A : B;
	}
}

dp muxreg(
	in S : ns(2);
	in A, B, C : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A :
				(S == 1) ? B : C ;
	}
}

dp register(
	in asel, bsel : ns(3);
	in storeenable : ns(1);
	in storesel : ns(3);
	in storedata : tc(32);
	out a, b: tc(32)
) {
	reg r0, r1, r2, r3, r4, r5, r6, r7 : tc(32);
	always {
		r1 = (storeenable == 1 & storesel == 1) ? storedata : r1;
		r2 = (storeenable == 1 & storesel == 2) ? storedata : r2;
		r3 = (storeenable == 1 & storesel == 3) ? storedata : r3;
		r4 = (storeenable == 1 & storesel == 4) ? storedata : r4;
		r5 = (storeenable == 1 & storesel == 5) ? storedata : r5;
		r6 = (storeenable == 1 & storesel == 6) ? storedata : r6;
		r7 = (storeenable == 1 & storesel == 7) ? storedata : r7; 

		a = (asel == 0) ? r0:
			(asel == 1) ? r1:
			(asel == 2) ? r2:
			(asel == 3) ? r3:
			(asel == 4) ? r4:
			(asel == 5) ? r5:
			(asel == 6) ? r6: r7;

		b = (bsel == 0) ? r0:
			(bsel == 1) ? r1:
			(bsel == 2) ? r2:
			(bsel == 3) ? r3:
			(bsel == 4) ? r4:
			(bsel == 5) ? r5:
			(bsel == 6) ? r6: r7;
	}

	$trace(r1, "traces/reg_r1.seq");
	$trace(r2, "traces/reg_r2.seq");
	$trace(r3, "traces/reg_r3.seq");
	$trace(r4, "traces/reg_r4.seq");
	$trace(r5, "traces/reg_r5.seq");
	$trace(r6, "traces/reg_r6.seq");
	$trace(r7, "traces/reg_r7.seq");
	$trace(storeenable, "traces/reg_storeenable.seq");
	$trace(storedata, "traces/reg_storedata.seq");
	$trace(storesel, "traces/reg_storesel.seq");

}



dp controller(
	in opcode : ns(4);
	in zero, neg : ns(1);

	out reg_storeEnable : ns(1); 
	out muxregsel : ns(2);
	out muxalusel, alu_sel, jumpEnable : ns(1)	
){
	reg reg_zero, reg_neg : ns(1);
	always {

		/*
		MOVE:  3, reg_storeEnable = 1, muxregsel = 1
		MOVEi: 4, reg_storeEnable = 1

		BZERO: 5, jumpEnable = zero, 
		BNEG; 6, jumpEnable = neg
		BRANCH: 7, jumpEnable = 1

		ADD:  8, reg_storeEnable = 1, muxregsel = 2, muxalusel = 1
		ADDi: 9, reg_storeEnable = 1, muxregsel = 2
		SUB:  10, reg_storeEnable = 1, alu_sel = 1, muxregsel = 2, muxalusel = 1
		*/

		reg_zero = zero;
		reg_neg = neg;


		reg_storeEnable = 	(opcode == 3) ? 1 :
							(opcode == 4) ? 1 :
							(opcode == 8) ? 1 :
							(opcode == 9) ? 1 :
							(opcode == 10) ? 1 : 0;

		alu_sel = (opcode == 10) ? 1 : 0;
		
		muxregsel = (opcode == 3) ? 1 : 
					(opcode == 8) ? 2 :
					(opcode == 9) ? 2 :
					(opcode == 10) ? 2 : 0;
		
		muxalusel = (opcode == 8) ? 1 :
					(opcode == 10) ? 1 : 0;
		
		jumpEnable = 	(opcode == 5) ? reg_zero : 
						(opcode == 6) ? reg_neg : 
						(opcode == 7) ? 1 : 0;

	}

	$trace(opcode, "traces/opcode.seq");
	$trace(jumpEnable, "traces/jumpEnable.seq");
}

dp CPU()
{
	//PC
	sig pc_out : ns(32);

	// ALU
	sig zero, neg : ns(1);
	sig alu_out : tc(32);

	// controller
	sig jumpEnable : ns(1);
	sig reg_storeEnable : ns(1);
	sig alu_sel : ns(2);
	sig muxregsel : ns(2);
	sig muxalusel : ns(1);

	// Mem
	sig w, r, i: ns(1);
	sig oData : ns(32);
	sig opcode : ns(4);
	sig R1, R2, R3 : ns(3);
	sig imm : ns(19);

	// Reg
	sig reg_aOut, reg_bOut : tc(32);

	// Mux
	sig muxalu_out, muxreg_out : tc(32);



	use PC(imm, jumpEnable, pc_out);
	use instmem(pc_out, w, r, i, oData);
	
	use controller(opcode, zero, neg, reg_storeEnable, muxregsel, muxalusel, alu_sel, jumpEnable);

	use alu( alu_sel, reg_aOut, muxalu_out, alu_out, zero, neg );
	use register(R2, R3, reg_storeEnable, R1, muxreg_out, reg_aOut, reg_bOut);
	use muxreg(muxregsel, imm, reg_aOut, alu_out, muxreg_out);
	use muxalu(muxalusel, imm, reg_bOut, muxalu_out);

	//use instmem(pc_out,0,1,0,odata)
	always{
		opcode = oData[31:28];
		R1 = oData[27:25];
		R2 = oData[24:22];
		R3 = oData[21:19];
		imm = oData[18:0];

		// Instmem selectors
		w = 0; r = 1; i = 0;


		$display($bin, "opcode: ", opcode);
	}
	
	$trace(pc_out, "traces/pc_out.seq");
}

system myFirstSystem {
	CPU;

	//disp(muxregout);

}
