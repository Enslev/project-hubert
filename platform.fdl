$option "vcd"
dp PC(
  in jumpTo : ns(10);
  in select : ns(2);
  out cout  : ns(32)
  ){
  reg c : ns(10);
  
  always{

    c = (select == 1) ? jumpTo: 
        (select == 2) ? c : c + 1;
    
    cout =  (select == 1) ? jumpTo: 
            (select == 2) ? c : c + 1;  

  }
  $trace(select, "traces/select.seq");
  $trace(c, "traces/c.seq");
  //$trace(cout, "traces/cout.seq");

}
ipblock instmem(
  in address  : ns(5);
  in wr,rd  : ns(1);
  in idata  : ns(32);
  out odata   : ns(32)
) {
  iptype "ram";
  ipparm "size=251";
  ipparm "wl=32";
  ipparm "file=instructions.txt";
}

dp add(
  in x, y : tc(32);
  out o : tc(32)
  ) { 
  always {
    o = x + y;
  }
}

dp sub(
  in x, y : tc(32);
  out o : tc(32)
  ) { 
  always {
    o = x - y;
  }
}

dp alu(
  in S : ns(1);
  in A, B : tc(32);
  out R : tc(32);
  out Z : ns(1);
  out N : ns(1)
) {
  sig Radd, Rsub : tc(32);

  use add(A, B, Radd);
  use sub(A, B, Rsub);

  always {
    R = (S == 0) ? Radd : Rsub;

    N = (R < 0) ? 1 : 0;
    Z = (R == 0) ? 1 : 0;
  }
  $trace(N, "traces/Neg.seq");
  $trace(Z, "traces/Zero.seq");

}

dp muxalu(
  in S : ns(1);
  in A, B : tc(32);
  out R : tc(32)
) { 
  always {
    R = (S == 0) ? A : B;
  }
}

dp muxreg(
  in S : ns(2);
  in imm, a_out, alu_out, mem : tc(32);
  out R : tc(32)
) { 
  always {
    R = (S == 0) ? imm     :
        (S == 1) ? a_out   :
        (S == 2) ? alu_out : mem;
  }
}

dp register(
  in asel, bsel : ns(3);
  in storeenable : ns(1);
  in storesel : ns(3);
  in storedata : tc(32);
  out a, b: tc(32)
) {
  reg r0, r1, r2, r3, r4, r5, r6, r7 : tc(32);
  always {
    r1 = (storeenable == 1 & storesel == 1) ? storedata : r1;
    r2 = (storeenable == 1 & storesel == 2) ? storedata : r2;
    r3 = (storeenable == 1 & storesel == 3) ? storedata : r3;
    r4 = (storeenable == 1 & storesel == 4) ? storedata : r4;
    r5 = (storeenable == 1 & storesel == 5) ? storedata : r5;
    r6 = (storeenable == 1 & storesel == 6) ? storedata : r6;
    r7 = (storeenable == 1 & storesel == 7) ? storedata : r7; 

    a = (asel == 0) ? r0:
      (asel == 1) ? r1:
      (asel == 2) ? r2:
      (asel == 3) ? r3:
      (asel == 4) ? r4:
      (asel == 5) ? r5:
      (asel == 6) ? r6: r7;

    b = (bsel == 0) ? r0:
      (bsel == 1) ? r1:
      (bsel == 2) ? r2:
      (bsel == 3) ? r3:
      (bsel == 4) ? r4:
      (bsel == 5) ? r5:
      (bsel == 6) ? r6: r7;
  }

  $trace(r1, "traces/reg_r1.seq");
  $trace(r2, "traces/reg_r2.seq");
  $trace(r3, "traces/reg_r3.seq");
  $trace(r4, "traces/reg_r4.seq");
  $trace(r5, "traces/reg_r5.seq");
  $trace(r6, "traces/reg_r6.seq");
  $trace(r7, "traces/reg_r7.seq");
  $trace(storeenable, "traces/reg_storeenable.seq");
  $trace(storedata, "traces/reg_storedata.seq");
  $trace(storesel, "traces/reg_storesel.seq");

}



dp controller(
  in opcode : ns(4);
  in zero, neg : ns(1);
  in dataoutrdy : ns(1);

  out reg_storeEnable : ns(1); 
  out muxregsel : ns(2);
  out muxalusel, alu_sel : ns(1);
  out pcSelect: ns(2)  
){
  reg reg_zero, reg_neg : ns(1);
  always {

    /*
    LOAD: 1, reg_storeEnable = 1, muxregsel = 3

    MOVE:  3, reg_storeEnable = 1, muxregsel = 1
    MOVEi: 4, reg_storeEnable = 1

    BZERO: 5, pcSelect= zero, 
    BNEG; 6, pcSelect= neg
    BRANCH: 7, pcSelect= 1

    ADD:  8, reg_storeEnable = 1, muxregsel = 2, muxalusel = 1
    ADDi: 9, reg_storeEnable = 1, muxregsel = 2
    SUB:  10, reg_storeEnable = 1, alu_sel = 1, muxregsel = 2, muxalusel = 1
    */

    reg_zero =  (opcode == 8)   ? zero:
                (opcode == 9)   ? zero:
                (opcode == 10)  ? zero: reg_zero;

    reg_neg =   (opcode == 8)   ? neg:
                (opcode == 9)   ? neg:
                (opcode == 10)  ? neg: reg_neg;

    reg_storeEnable =   (opcode == 1) ? dataoutrdy :
                        (opcode == 3) ? 1 :
                        (opcode == 4) ? 1 :
                        (opcode == 8) ? 1 :
                        (opcode == 9) ? 1 :
                        (opcode == 10) ? 1 :
                        (opcode == 11) ? dataoutrdy : 0;

    alu_sel = (opcode == 10) ? 1 : 0;
    
    muxregsel = (opcode == 1) ? 3 :
                (opcode == 3) ? 1 : 
                (opcode == 8) ? 2 :
                (opcode == 9) ? 2 :
                (opcode == 10) ? 2 :
                (opcode == 11) ? 3 : 0;
    
    muxalusel = (opcode == 8) ? 1 :
                (opcode == 10) ? 1 : 0;
    
    pcSelect =    (opcode == 1 & dataoutrdy == 0) ? 2 :
                  (opcode == 2 & dataoutrdy == 0) ? 2 :
                  (opcode == 5) ? reg_zero : 
                  (opcode == 6) ? reg_neg : 
                  (opcode == 7) ? 1 :
                  (opcode == 11 & dataoutrdy == 0) ? 2 : 0;

  }

  $trace(opcode, "traces/opcode.seq");
  $trace(pcSelect, "traces/pcSelect.seq");
}

////////////////////////////
// CPU
////////////////////////////

dp CPU(

 out M_datain : ns(32);
 out M_cmd : ns(32);
 out M_datainrdy : ns(1);
 in M_dataout : ns(32);
 in M_dataoutrdy : ns(1)
 //in stall_cpu : ns(1)

) {
  //PC
  sig pc_out : ns(10);

  // ALU
  sig zero, neg : ns(1);
  sig alu_out : tc(32);

  // controller
  sig pcSelect: ns(2);
  sig reg_storeEnable : ns(1);
  sig alu_sel : ns(2);
  sig muxregsel : ns(2);
  sig muxalusel : ns(1);

  // Mem
  sig w, r, i: ns(1);
  sig oData : ns(32);
  sig opcode : ns(4);
  sig R1, R2, R3 : ns(3);
  sig imm : ns(19);

  reg reg_opcode : ns(4);

  // Reg
  sig reg_aOut, reg_bOut : tc(32);

  // Mux
  sig muxalu_out, muxreg_out : tc(32);

  use PC(imm, pcSelect, pc_out);
  use instmem(pc_out, w, r, i, oData);
  
  use controller(opcode, zero, neg, M_dataoutrdy, reg_storeEnable, muxregsel, muxalusel, alu_sel, pcSelect);

  use alu( alu_sel, reg_aOut, muxalu_out, alu_out, zero, neg );
  use register(R2, R3, reg_storeEnable, R1, muxreg_out, reg_aOut, reg_bOut);
  use muxreg(muxregsel, imm, reg_aOut, alu_out, M_dataout, muxreg_out);
  use muxalu(muxalusel, imm, reg_bOut, muxalu_out);

  //use instmem(pc_out,0,1,0,odata)
  always {
    opcode = oData[31:28];
    R1 = oData[27:25];
    R2 = oData[24:22];
    R3 = oData[21:19];
    imm = oData[18:0];

    // Instmem selectors
    w = 0; r = 1; i = 0;

    // Bus
    // loadcmd 0x20000000
    // writecmd 0x28000000

    //M_datain = (opcode == 1) ? 91 : 0;
    //M_cmd = (opcode == 1) ? 0x20000000 : 0;
    //M_datainrdy =  (opcode == 1) ? 1 : 0;

    /*
    M_datain =  (opcode == 1) ? reg_bOut :
                (opcode == 2) ? reg_aOut : 0;

    M_cmd = (opcode == 1) ? 0x20000000  :
            (opcode == 2) ? 0x28000000 + reg_bOut : 0;

    M_datainrdy = (opcode == 1) ? 1 :
                  (opcode == 2) ? 1 : 0;
    */



    M_datain =  (opcode == 1) ? reg_bOut :
                (opcode == 2) ? reg_aOut :
                (opcode == 11) ? reg_bOut : 0 ;

    M_cmd = (opcode == 1) ? 0x20000000  :
            (opcode == 2) ? 0x28000000 + reg_bOut :
            (opcode == 11) ? 0x40000001 : 0; // ID = 4

    M_datainrdy = (opcode == 1) ? 1 :
                  (opcode == 2) ? 1 :
                  (opcode == 11) ? 1 : 0;


    reg_opcode = opcode;

    $display($bin, "opcode: ", opcode);
  }
  
  $trace(pc_out, "traces/pc_out.seq");
  $trace(M_dataoutrdy, "traces/M_dataoutrdy.seq");
  $trace(M_datainrdy, "traces/M_datainrdy.seq");
  $trace(M_dataout, "traces/M_dataout.seq");
  $trace(M_datain, "traces/M_datain.seq");
  $trace(M_cmd, "traces/M_cmd.seq");

}


//
// Co-processor
//
dp addCO(
  in x, y : ns(32);
  out o : ns(32)
  ) { 
  always {
    o = x + y;
  }
}

dp subCO(
  in x, y : ns(32);
  out o : ns(32)
  ) { 
  always {
    o = x - y;
  }
}

dp div32(
  in x : ns(32);
  out o : ns(32)
  ) { 
  always {
    //o = x >> 5;
    o = x[31: 5];
  }
}

dp regs (
  in enable : ns(1);
  in datain : ns(32);
  out regout : ns(32)
) {
  reg r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, 
    r11, r12, r13, r14, r15, r16, r17, r18, r19, r20,
    r21, r22, r23, r24, r25, r26, r27, r28, r29, r30,
    r31, r32 : ns(32);

  always {

    r1 = enable ? datain : r1;
    r2 = enable ? r1 : r2;
    r3 = enable ? r2 : r3;
    r4 = enable ? r3 : r4;
    r5 = enable ? r4 : r5;
    r6 = enable ? r5 : r6;
    r7 = enable ? r6 : r7;
    r8 = enable ? r7 : r8;
    r9 = enable ? r8 : r9;
    r10 = enable ? r9 : r10;
    r11 = enable ? r10 : r11;
    r12 = enable ? r11 : r12;
    r13 = enable ? r12 : r13;
    r14 = enable ? r13 : r14;
    r15 = enable ? r14 : r15;
    r16 = enable ? r15 : r16;
    r17 = enable ? r16 : r17;
    r18 = enable ? r17 : r18;
    r19 = enable ? r18 : r19;
    r20 = enable ? r19 : r20;
    r21 = enable ? r20 : r21;
    r22 = enable ? r21 : r22;
    r23 = enable ? r22 : r23;
    r24 = enable ? r23 : r24;
    r25 = enable ? r24 : r25;
    r26 = enable ? r25 : r26;
    r27 = enable ? r26 : r27;
    r28 = enable ? r27 : r28;
    r29 = enable ? r28 : r29;
    r30 = enable ? r29 : r30;
    r31 = enable ? r30 : r31;
    r32 = enable ? r31 : r32;

    regout = r32;
    

  }

}


dp Filter(
  in datain : ns(32); // tc
  in cmd : ns(32);
  in datainrdy : ns(1);
  out dataout : ns(32); // tc
  out dataoutrdy : ns(1);
  in stall : ns(1)
  // out FilterOut : tc(32)
) {
  sig addout, subout, x32 : ns(32);
  reg sum : ns(32);

  use addCO(datain, sum, addout);
  use subCO(addout, x32, subout);
  use div32(sum, dataout);
  use regs(datainrdy, datain, x32);

  reg hasBeenRdy : ns(1);


  always {
    dataoutrdy = (hasBeenRdy == 1 & stall == 0) ? 1 : 0;

    
    hasBeenRdy =  (datainrdy == 1) ? 1 :
                  (stall == 0) ? 0 :
                  hasBeenRdy;
    


    sum = (datainrdy == 1) ? subout : sum;

  }
 
  $trace(dataout, "traces/dataout.seq");
  $trace(dataoutrdy, "traces/dataoutrdy.seq");
  $trace(datain, "traces/datain.seq");
  $trace(sum, "traces/sum.seq");
  $trace(stall, "traces/stall.seq");
  $trace(hasBeenRdy, "traces/hasBeenRdy.seq");
  $trace(datainrdy, "traces/datainrdy.seq");

}

////////////////////////////
// Bus
////////////////////////////

dp bus(
        // CPU interface
        in reqCPU  : ns(1);
        in cmdCPU : ns(32); // What command should be executed at the unit receiving this + ID of destination unit is in 4 MSB
        in dataoutCPU : ns(32); // data from the CPU
        out ackCPU : ns(1); 
                
        out dataRdyCPU : ns(1); // high when unit has data, which is ready for the CPU
        out datainCPU : ns(32); // data to the CPU
        in waitCPU : ns(1); // Remains high until the CPU has read the data
                
        // Data Memory interface
        out reqDataMem : ns(1);
        out cmdDataMem : ns(32);
        out datainDataMem : ns(32); // data to Data memory from CPU
        in ackDataMem : ns(1);
               
        in dataRdyDataMem : ns(1); 
        in dataoutDataMem : ns(32); // data from Data memory to CPU
        out waitDataMem : ns(1);
        
        // Sensor interface
        out reqSensor : ns(1);
        out cmdSensor : ns(32); // only cmd is needed to the sensor
        out NotUsed1 : ns(32); // dataport not used
        in ackSensor : ns(1);
        
        in dataRdySensor : ns(1);
        in dataoutSensor : ns(32);
        out waitSensor : ns(1);
        
        // Output interface
        out reqOutput : ns(1);
        out cmdOutput : ns(32);
        out datainOutput : ns(32); // data to output from CPU
        in ackOutput : ns(1);
               
        in dataRdyOutput : ns(1); 
        in dataoutOutput : ns(32); // data from output to CPU
        out waitOutput : ns(1);
        
        // Filter interface
        out reqFilter : ns(1);
        out cmdFilter : ns(32);
        out datainFilter : ns(32); // dataport not used
        in ackFilter : ns(1);
               
        in dataRdyFilter : ns(1); 
        in dataoutFilter : ns(32); // data from Filter to CPU
        out waitFilter : ns(1);

        // IDs
        in ID_Sensor : ns(4);
        in ID_DataMem : ns(4);
        in ID_Output : ns(4);
	      in ID_Filter : ns(4)

        ){
        
        $trace(reqDataMem, "traces/reqDataMem.seq");
        $trace(cmdDataMem, "traces/cmdDataMem.seq");
        $trace(datainDataMem, "traces/datainDataMem.seq");
        $trace(ackDataMem, "traces/ackDataMem.seq");
        $trace(dataRdyDataMem, "traces/dataRdyDataMem.seq");
        $trace(dataoutDataMem, "traces/dataoutDataMem.seq");
        $trace(waitDataMem, "traces/waitDataMem.seq");
        
        $trace(reqSensor, "traces/reqSensor.seq");
        $trace(cmdSensor, "traces/cmdSensor.seq");
        $trace(ackSensor, "traces/ackSensor.seq");
        $trace(dataRdySensor, "traces/dataRdySensor.seq");
        $trace(dataoutSensor, "traces/dataoutSensor.seq");
        $trace(waitSensor, "traces/waitSensor.seq");
        
        $trace(reqOutput, "traces/reqOutput.seq");
        $trace(cmdOutput, "traces/cmdOutput.seq");
        $trace(datainOutput, "traces/datainOutput.seq");
        $trace(ackOutput, "traces/ackOutput.seq");
        $trace(dataRdyOutput, "traces/dataRdyOutput.seq");
        $trace(dataoutOutput, "traces/dataoutOutput.seq");
        $trace(waitOutput, "traces/waitOutput.seq");
        
        $trace(reqCPU, "traces/reqCPU.seq");
        $trace(cmdCPU, "traces/cmdCPU.seq");
        $trace(dataoutCPU, "traces/dataoutCPU.seq");
        $trace(ackCPU, "traces/ackCPU.seq");
        $trace(dataRdyCPU, "traces/dataRdyCPU.seq");
        $trace(datainCPU, "traces/datainCPU.seq");
        $trace(waitCPU, "traces/waitCPU.seq");
        
        always{
          ackCPU = (cmdCPU[28:31] == ID_DataMem & ackDataMem) | (cmdCPU[28:31] == ID_Sensor & ackSensor) | (cmdCPU[28:31] == ID_Output & ackOutput) | (cmdCPU[28:31] == ID_Filter & ackFilter); // "OR" all slaves ack signals here
          dataRdyCPU = dataRdyDataMem | dataRdySensor | dataRdyOutput | dataRdyFilter; // Only one slave can access the bus at any one time (only the slave which responds to the cmd)
          
          reqDataMem = reqCPU;
          cmdDataMem = (reqCPU) ? cmdCPU : 0;
          datainDataMem = (reqCPU) ? dataoutCPU : 0;
          
          reqSensor = reqCPU;
          cmdSensor = (reqCPU) ? cmdCPU : 0;
          waitSensor = waitCPU;
          
          reqOutput = reqCPU;
          cmdOutput = (reqCPU) ? cmdCPU : 0;
          datainOutput = (reqCPU) ? dataoutCPU : 0;
          waitOutput = waitCPU;
          
          reqFilter = reqCPU;
          cmdFilter = (reqCPU) ? cmdCPU : 0;
          datainFilter = (reqCPU) ? dataoutCPU : 0;
          waitFilter = waitCPU;

          datainCPU = (dataRdyDataMem) ? dataoutDataMem : 
                      (dataRdySensor) ? dataoutSensor : 
                      (dataRdyOutput) ? dataoutOutput :
                      (dataRdyFilter) ? dataoutFilter :
                      0; // arbitrate here when multiple slaves
          waitDataMem = waitCPU;
          
          NotUsed1 = 0;
        }       
}

dp slavebusinterface(
          // Bus ports
          in bus_req : ns(1);
          in bus_cmd : ns(32);
          in bus_datain : ns(32);
          out bus_ack : ns(1);
          
          out bus_rdy : ns(1);
          out bus_dataout : ns(32);
          in bus_wait : ns(1);
          
          // Slave ports - data going in to the slave does not need a handshake. 
          in datain : ns(32); // data from main unit to interface
          in datainrdy : ns(1); // slave signals that data and cmd is rdy
          out dataout : ns(32); // data to slave
          out cmdout : ns(32); // cmd to slave
          out dataoutrdy : ns(1); // signal to slave telling that the data on dataout is rdy
          in targetID : ns(4); // specifies the ID used in the MSB of CMD, which is intended for this slave
          out stallSlave : ns(1) // true if the slaveinterface is currently busy and cannot receive data from the slave
          ){
          
          reg bus_reqr : ns(1);
          reg bus_waitr : ns(1);
          reg datainrdyr : ns(1);
          reg targetIDr : ns(4);
          reg bus_cmdr : ns(32);
          
          always{
             bus_reqr = bus_req;
             bus_waitr = bus_wait;
             datainrdyr = datainrdy;
             targetIDr = targetID;
             bus_cmdr = bus_cmd;

             //$display($dec, bus_rdy);
             //$display($dec, bus_dataout);
          }
          
          sfg externalData{
             bus_ack = 1;
             dataout = bus_datain;
             cmdout = bus_cmd;
             dataoutrdy = bus_cmd[28:31] == targetID; // is the cmd and data intended for this slave?
             
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }
          
          sfg ackExternalData{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }
          
          sfg internalData{
             bus_dataout = datain;
             bus_rdy = 1;
             
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }
          
          sfg ackInternalData{
             bus_rdy = 0;
             bus_dataout = 0;
             
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }
          
          sfg nothing{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 0;
          }
          
}

fsm slavebusinterface_cntrl(slavebusinterface){
   initial s0;
   state s1,s2,s3;
   
   // condition explanation: Only ack if the cmd is intended for this slave
   @s0 if (bus_reqr == 1 & bus_cmdr[28:31] == targetIDr) then (externalData) -> s1;
       else (nothing) -> s0;
   @s1 if (bus_reqr == 0) then (ackExternalData) ->s2;
       else (externalData) -> s1;
   @s2 if (datainrdyr == 1) then (internalData) -> s3;
       else (nothing) -> s2;
   @s3 if (bus_waitr == 1) then (ackInternalData) -> s0;
       else (internalData) -> s3;
   
}

dp slavebusinterface2 : slavebusinterface
dp slavebusinterface3 : slavebusinterface
dp slavebusinterface4 : slavebusinterface

dp masterbusinterface(
          // Bus ports
          out bus_req : ns(1); // master request the bus
          out bus_cmd : ns(32); // cmd to target unit
          out bus_dataout : ns(32); // data to target unit
          in bus_ack : ns(1); // ack from bus
                      
          in bus_rdy : ns(1); // rdy from bus
          in bus_datain : ns(32); // data targeted for the master
          out bus_wait : ns(1); // wait to bus
                    
          // Master ports - data going in to the master does not need a handshake. 
          in datain : ns(32); // data from main unit to interface
          in cmd : ns(32); // command from main unit to interface
          in datainrdy : ns(1); // master signals that data and cmd is rdy
          out dataout : ns(32); // data to master
          out dataoutrdy : ns(1) // signal to master telling that the data on dataout is rdy
          ){
          
//          $trace(bus_req, "traces/M_bus_req.seq");
//          $trace(bus_cmd, "traces/M_bus_cmd.seq");
//          $trace(bus_dataout, "traces/M_bus_dataout.seq");
//         $trace(datain, ); $trace(bus_ack, "traces/M_bus_ack.seq");
//          $trace(bus_rdy, "traces/M_bus_rdy.seq");
//          $trace(bus_datain, "traces/M_bus_datain.seq");
//          $trace(bus_wait, "traces/M_bus_wait.seq");
          
//          $trace(datain, "traces/M_datain_int.seq");
//          $trace(cmd, "traces/M_cmd_int.seq");
//          $trace(datainrdy, "traces/M_datainrdy_int.seq");
//          $trace(dataout, "traces/M_dataout_int.seq");
//          $trace(dataoutrdy, "traces/M_dataoutrdy_int.seq");
          
          reg bus_ackr : ns(1);
          reg bus_rdyr : ns(1);
          reg datainrdyr : ns(1);
          reg cmdr : ns(32);
          reg datainr : ns(32);
                      
          always{
             bus_ackr = bus_ack;
             bus_rdyr = bus_rdy;
             datainrdyr = datainrdy;
             cmdr = cmd;
             datainr = datain;
          }
          
          sfg internalData{
             bus_req = 1;
             bus_cmd = cmd;
             bus_dataout = datain;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
          
          sfg ackInternalData{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
          
          sfg externalData{
             bus_wait = 1;
             dataout = bus_datain;
             dataoutrdy = 1;
             
             bus_req = 0;
             bus_cmd = 0;
             bus_dataout = 0;
          }
          
          sfg ackExternalData{
              bus_wait = 0;
              dataout = 0;
              dataoutrdy = 0;
              
              bus_req = 0;
              bus_cmd = 0;
              bus_dataout = 0;
          }
                    
          sfg nothing{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;
             
             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
}

fsm masterbusinterface_cntrl(masterbusinterface){
   initial s0;
   state s1,s2,s3,s4;
   
   @s0 if (datainrdyr == 1) then (internalData) -> s1;
       else (nothing) -> s0; // do nothing
   @s1 if (bus_ackr == 1) then (ackInternalData) -> s3; // go to s3 in order to make sure the bus will not initiate a new communication due to the fact that the CPU is stalled at this particular bus-using instruction
       else (internalData) -> s1; // do nothing
   @s3 if (bus_rdyr == 1) then (externalData) -> s2;
       else (nothing) -> s3;
   @s2 (ackExternalData) -> s4; 
   @s4 (nothing) -> s0; // Wait one more cycle to synchronize with PC
}

dp bus_toplevel(
           // Master interface
           in M_datain : ns(32);
           in M_cmd : ns(32);
           in M_datainrdy : ns(1);
           out M_dataout : ns(32);
           out M_dataoutrdy : ns(1);
           //out stall_cpu : ns(1);
           
           // Slave interface (datamemory)
           in DM_datain : ns(32);
           in DM_datainrdy : ns(1);
           out DM_dataout : ns(32);
           out DM_cmdout : ns(32);
           out DM_dataoutrdy : ns(1);
           out DM_stall : ns(1);
           
           // Slave interface (Sensor)
           in SS_datain : ns(32);
           in SS_datainrdy : ns(1);
           out SS_dataout : ns(32); // data port not used in sensor
           out SS_cmdout : ns(32);
           out SS_dataoutrdy : ns(1);
           out SS_stall : ns(1);
           
           // Slave interface (Output)
           in OP_datain : ns(32);
           in OP_datainrdy : ns(1);
           out OP_dataout : ns(32); 
           out OP_cmdout : ns(32);
           out OP_dataoutrdy : ns(1);
           out OP_stall : ns(1);

           // Slave interface (Filter)
           in FI_datain : ns(32);
           in FI_datainrdy : ns(1);
           out FI_dataout : ns(32); 
           out FI_cmdout : ns(32);
           out FI_dataoutrdy : ns(1);
           out FI_stall : ns(1)

           ){
           
           sig reqCPU,reqDataMem,reqSensor,reqOutput,reqFilter,ackCPU,ackDataMem,ackSensor,ackOutput,ackFilter,dataRdyCPU,dataRdyDataMem,dataRdySensor,dataRdyOutput,dataRdyFilter,waitCPU,waitDataMem,waitSensor,waitOutput,waitFilter: ns(1);
           sig cmdCPU,cmdDataMem,cmdSensor,cmdOutput,cmdFilter,dataoutCPU,datainDataMem,datainSensor,datainOutput,datainFilter,datainCPU,dataoutDataMem,dataoutSensor,dataoutOutput,dataoutFilter : ns(32);
           reg ID_DataMem : ns(4);
           reg ID_Sensor : ns(4);
           reg ID_Output : ns(4);
           reg ID_Filter : ns(4);
           
           $trace(DM_datain, "traces/DM_datain.seq");
           $trace(DM_datainrdy, "traces/DM_datainrdy.seq");
           $trace(DM_dataout, "traces/DM_dataout.seq");
           $trace(DM_cmdout, "traces/DM_cmdout.seq");
           $trace(DM_dataoutrdy, "traces/DM_dataoutrdy.seq");
           
           $trace(SS_datain, "traces/SS_datain.seq");
           $trace(SS_datainrdy, "traces/SS_datainrdy.seq");
           $trace(SS_dataout, "traces/SS_dataout.seq");
           $trace(SS_cmdout, "traces/SS_cmdout.seq");
           $trace(SS_dataoutrdy, "traces/SS_dataoutrdy.seq");
           
           $trace(OP_datain, "traces/OP_datain.seq");
           $trace(OP_datainrdy, "traces/OP_datainrdy.seq");
           $trace(OP_dataout, "traces/OP_dataout.seq");
           $trace(OP_cmdout, "traces/OP_cmdout.seq");
           $trace(OP_dataoutrdy, "traces/OP_dataoutrdy.seq");
           
           use bus(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU, // master
                   reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem, // Data memory (slave)
                   reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor, // Sensor (slave)
                   reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput, // Output (slave)
                   reqFilter,cmdFilter,datainFilter,ackFilter,dataRdyFilter,dataoutFilter,waitFilter, // Filter (slave)
                   ID_Sensor,ID_DataMem,ID_Output, ID_Filter); 
           
           use masterbusinterface(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU, // Bus interface
                                  //CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy
                                  M_datain,M_cmd,M_datainrdy,M_dataout,M_dataoutrdy);

           use slavebusinterface(reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem, // Bus interface (data memory)
                             //DMDatain,DMDatainrdy,DMDataout,DMCmdout,DMDataoutrdy,
                             DM_datain,DM_datainrdy,DM_dataout,DM_cmdout,DM_dataoutrdy,ID_DataMem,DM_stall);
                             
           use slavebusinterface2(reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor, // Bus interface (Sensor)
                              //SensorDatain,SensorDatainrdy,NotUsed2,SensorCmdout,SensorDataoutrdy,
                              SS_datain,SS_datainrdy,SS_dataout,SS_cmdout,SS_dataoutrdy,ID_Sensor,SS_stall);
                              
           use slavebusinterface3(reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput, // Bus interface (Output)
                              //OPDatain,OPDatainrdy,OPDataout,OPCmdout,OPDataoutrdy,
                              OP_datain,OP_datainrdy,OP_dataout,OP_cmdout,OP_dataoutrdy,ID_Output,OP_stall);

           use slavebusinterface4(reqFilter,cmdFilter,datainFilter,ackFilter,dataRdyFilter,dataoutFilter,waitFilter, // Bus interface (Filter)
                              //FilterDatain,FilterDatainrdy,FilterDataout,FilterCmdout,FilterDataoutrdy,
                              FI_datain,FI_datainrdy,FI_dataout,FI_cmdout,FI_dataoutrdy,ID_Filter,FI_stall);
           
           always{
              ID_Sensor = 0x1;
              ID_DataMem = 0x2;
              ID_Output = 0x3;
              ID_Filter = 0x4;
           }
}

////////////////////////////
// Auxiliary units
////////////////////////////
ipblock datamem(in address : ns(12);
          in wr,rd   : ns(1);
          in idata   : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=4096";
  ipparm "wl=32";
  ipparm "file=datamemory.txt"; // initializes content. File syntax needs to be "addr data "* (the last space can also be a linebreak. NB! Should the students do a manual loading of the RAM to simulate a "real" system or is it ok if they just use this parameter?
  //ipparm "file=sddb48hex2.ecg"; 
}

dp DataMem(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1) // true if the slave is currently busy (with handshaking) and cannot receive new data.
   ){
   
   sig wr,rd : ns(1);
   sig address : ns(12);
   sig idata : ns(32);
   
   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);
   
   use datamem(address,wr,rd,idata,dataout);
   
   $trace(address, "traces/DM_address.seq");
   $trace(wr, "traces/DM_wr.seq");
   $trace(rd, "traces/DM_rd.seq");
   $trace(idata, "traces/DM_idata.seq");
   
   always{
       stallr = stall;
       rd = cmdr[27] == 0;
       wr = cmdr[27] == 1;
       address = (cmdr[27] == 0) ? datainr : 0b00000 # cmdr[0:26]; // if Store Word instruction, use cmd[0:26] as address. If Load Word instruction use datain as address
       idata = (cmdr[27] == 0) ? 0 : datainr; // if store word use datain as data to be stored, if load word, just set idata to 0
       //$display($dec, "Cycle: ", $cycle);
   	   //$display($dec, "   address: ", address);
   }
   
   sfg captureData{
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0; 
   }
   
}

fsm DataMem_cntrl(DataMem){
   initial s0;
   state s1;
   
   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy) -> s0;
       else (awaithandshake) -> s1;
       
}

ipblock sensordata(in address : ns(5);
          in wr,rd   : ns(1);
          in idata   : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=32";
  ipparm "wl=32";
  ipparm "file=sddb48hex.ecg"; // initializes content
  
}

dp Sensor(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1) // true if the slave is currently busy (with handshaking) and cannot receive new data.
   ){
   
    sig address : ns(5);
    sig wr,rd : ns(1);
    sig idata,odata : ns(32);
    
    use sensordata(address,wr,rd,idata,odata);

   	reg c : ns(10);
   	reg reset : ns(1);
   	reg addr : ns(8);
   	reg LIMIT : ns(10); // How many cycles to wait before it "acquires" the next datapoint (simulated sampling rate)
   	reg stallr : ns(1);
   	reg datainrdyr : ns(1);
   	
   	$trace(odata, "traces/SS_data.seq");
   	$trace(c, "traces/SS_c.seq");
   	
   	always{
   		wr = 0;
   		idata = 0;
   		LIMIT = 9; // 0 means 1 cycles => Pick new point each cycle TODO: Set proper sampling rate
   		address = addr;
   		
   		dataout = odata;
   		//dataoutrdy = 0;
   		stallr = stall;
   		//$display($dec, "Cycle: ", $cycle);
   		//$display($dec, "   data: ", odata);
   		//$display($dec, "   address: ", address);
   	}
   	
   sfg captureData{  
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       // Removed all datain and cmd capturing registers, due to the fact that the sensor only has one function, which is to send data once requested
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0; 
   }

	sfg count{
    	c = c + 1;
    	rd = 0;
	}
   	
   	sfg addressUpdate{
   	   addr = addr + 1;
   	   rd = 1;
   	   c = 0;
   	}

}

fsm sensor_cntrl(Sensor){
   initial s0;
   state s1;
       
   @s0 if (datainrdyr == 1 & stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 0 &  c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1 & c == LIMIT) then (addressUpdate,nothing) -> s1;
       else if (datainrdyr == 1 & stallr == 1 & c != LIMIT) then (count,nothing) -> s1;
       else if (datainrdyr == 0 & c == LIMIT) then (addressUpdate,captureData) -> s0;
       else (count,captureData) -> s0;
   @s1 if (stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (stallr == 0 & c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (stallr == 1 & c == LIMIT) then (addressUpdate,awaithandshake) -> s1;
       else (count,awaithandshake) -> s1;
}

dp Output(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1); // true if the slave is currently busy (with handshaking) and cannot receive new data.
   out FilterOut : tc(32)
   ){
   
   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);
   reg count : ns(10);
   reg FilterOut_r : tc(32);
   
   $trace(FilterOut, "traces/FilterOut.seq");
   $trace(count, "traces/out_count.seq");
   
   always{
       stallr = stall;
       dataout = 0x123;
   }
   
   sfg captureData{
       dataoutrdy = 0; 
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;
       
       FilterOut = FilterOut_r;
   }
   
   sfg awaithandshake{
      dataoutrdy = 0;
      
      FilterOut = FilterOut_r;
   }
   
   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }
   
   sfg nothing{
       dataoutrdy = 0;
       
       FilterOut = FilterOut_r;
   }
   
   sfg setFilterOut{
      FilterOut = datainr;
      FilterOut_r = datainr;
      count = count + 1;
   }
   
}

fsm Output_cntrl(Output){
   initial s0;
   state s1;
   
   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else (awaithandshake) -> s1;
       
}


//
//
//

////////////////////////////
// System connections
////////////////////////////
system CPUsystem{

   CPU(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy);
   
   bus_toplevel(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy, // master unit
           DMDatain,DMDatainrdy,DMDataout,DMCmdout,DMDataoutrdy,DMStall, // slave (data memory)
           SensorDatain,SensorDatainrdy,SensorDataout,SensorCmdout,SensorDataoutrdy,SensorStall,  // slave (sensor)
           OPDatain,OPDatainrdy,OPDataout,OPCmdout,OPDataoutrdy,OPStall, // slave (Output)
           FIDatain,FIDatainrdy,FIDataout,FICmdout,FIDataoutrdy,FIStall); // slave (Filter)
           
   DataMem(DMDataout,DMCmdout,DMDataoutrdy,DMDatain,DMDatainrdy,DMStall); // Data Memory Unit
   Sensor(SensorDataout,SensorCmdout,SensorDataoutrdy,SensorDatain,SensorDatainrdy,SensorStall);
   Output(OPDataout,OPCmdout,OPDataoutrdy,OPDatain,OPDatainrdy,OPStall,FilterOut);
   Filter(FIDataout,FICmdout,FIDataoutrdy,FIDatain,FIDatainrdy,FIStall);
}