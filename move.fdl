dp mux1(
	in S : ns(1);
	in A, B : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A : B;
	}
}

dp mux2(
	in S : ns(1);
	in A, B : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A : B;
	}
}


dp mux3(
	in S : ns(2);
	in A, B, C : tc(32);
	out R : tc(32)
) { 
	always {
		R = (S == 0) ? A :
			(S == 1) ? B : C;
	}
}

dp register(
	in asel, bsel : ns(3);
	in storeenable : ns(1);
	in storesel : ns(3);
	in storedata : tc(32);
	out a, b: tc(32)
) {
	reg r0, r1, r2, r3, r4, r5, r6, r7 : tc(32);
	always {
		r1 = (storeenable == 1 & storesel == 1) ? storedata : r1;
		r2 = (storeenable == 1 & storesel == 2) ? storedata : r2;
		r3 = (storeenable == 1 & storesel == 3) ? storedata : r3;
		r4 = (storeenable == 1 & storesel == 4) ? storedata : r4;
		r5 = (storeenable == 1 & storesel == 5) ? storedata : r5;
		r6 = (storeenable == 1 & storesel == 6) ? storedata : r6;
		r7 = (storeenable == 1 & storesel == 7) ? storedata : r7; 

		a = (asel == 0) ? r0:
			(asel == 1) ? r1:
			(asel == 2) ? r2:
			(asel == 3) ? r3:
			(asel == 4) ? r4:
			(asel == 5) ? r5:
			(asel == 6) ? r6: r7;

		b = (bsel == 0) ? r0:
			(bsel == 1) ? r1:
			(bsel == 2) ? r2:
			(bsel == 3) ? r3:
			(bsel == 4) ? r4:
			(bsel == 5) ? r5:
			(bsel == 6) ? r6: r7;
	}
}

dp testReg(
	in a, b : tc(32);
	out asel, bsel : ns(5);
	out storeenable : ns(1);
	out storesel : ns(3);
	out storedata : tc(32);
	out sel1, sel2 : ns(1);
	out sel3 : ns(2)
 ) {
	always{
		$display($dec, "Cycle:", $cycle, ", Aout=", a, ", Bout=", b, ", asel=", asel, ", bsel=", bsel);
		$display($dec, "storeenable=", storeenable, ", storesel=", storesel, ", storedata=", storedata);

		$display($dec, "");
	}

	sfg test_0 { asel=3; bsel=6; storeenable=1; storesel=1; storedata=6; sel1 = 0; sel2 = 0; sel3 = 0; }
	sfg test_1 { asel=1; bsel=6; storeenable=1; storesel=2; storedata=3; sel1 = 0; sel2 = 0; sel3 = 0; }
	sfg test_2 { asel=1; bsel=2; storeenable=0; storesel=3; storedata=17; sel1 = 0; sel2 = 1; sel3 = 0; }
	

	

	/*	
	// mux3 test bla
	sfg test_0 { asel=3; bsel=6; storeenable=1; storesel=1; storedata=5; sel1 = 1; sel2 = 0; sel3 = 0; }
	sfg test_1 { asel=1; bsel=6; storeenable=1; storesel=2; storedata=3; sel1 = 1; sel2 = 1; sel3 = 1; }
	sfg test_2 { asel=1; bsel=2; storeenable=0; storesel=3; storedata=17; sel1 = 1; sel2 = 1; sel3 = 0; }
	*/

	/*
	// test mux2
	sfg test_0 { asel=3; bsel=6; storeenable=1; storesel=1; storedata=4; sel1 = 1; sel2 = 0; sel3 = 0; }
	sfg test_1 { asel=1; bsel=6; storeenable=1; storesel=2; storedata=3; sel1 = 1; sel2 = 1; sel3 = 1; }
	sfg test_2 { asel=1; bsel=4; storeenable=0; storesel=3; storedata=17; sel1 = 1; sel2 = 1; sel3 = 0; }
	*/

	/*
	// test mux1
	sfg test_0 { asel=1; bsel=1; storeenable=1; storesel=1; storedata=3; sel1 = 0; sel2 = 0; sel3 = 0; }
	sfg test_1 { asel=5; bsel=6; storeenable=1; storesel=3; storedata=4; sel1 = 1; sel2 = 1; sel3 = 1; }
	sfg test_2 { asel=1; bsel=4; storeenable=0; storesel=3; storedata=17; sel1 = 1; sel2 = 1; sel3 = 0; }
	*/
	
}

// note : State machine to control the adder testbench.
fsm f_testbench(testReg) {
	initial s0; // begin with state s0
	state s1, s2; // other states are: s1, s2
	@s0 (test_0) -> s1; // run test_0 and go to s1
	@s1 (test_1) -> s2; // run test_1 and go to s2
	@s2 (test_2) -> s0; // run test_2 and go to s0
}

system myFirstSystem {
	
	
	register(asel, r1, storeenable, r2, r3, a, b);
	mux1(sel1, bsel, a, r1);
	mux2(sel2, storesel, a, r2);
	mux3(sel3, storedata, a, b, r3);
	testReg(a, b, asel, bsel, storeenable, storesel, storedata, sel1, sel2, sel3);
	

	/*
	register(asel, bsel, storeenable, storesel, r3, a, b);	
	mux3(sel3, storedata, a, b, r3);
	testReg(a, b, asel, bsel, storeenable, storesel, storedata, sel1, sel2, sel3);
	*/

	/*
	register(asel, bsel, storeenable, r2, storedata, a, b);	
	mux2(sel2, storesel, a, r2);
	testReg(a, b, asel, bsel, storeenable, storesel, storedata, sel1, sel2, sel3);
	*/

	/*
	register(asel, r1, storeenable, storesel, storedata, a, b);	
	mux1(sel1, bsel, a, r1);
	testReg(a, b, asel, bsel, storeenable, storesel, storedata, sel1, sel2, sel3);
	*/

}